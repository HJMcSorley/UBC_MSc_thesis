---
title: "Profiling water quality changes during stormflow"
subtitle: "Reproducible data analysis: Pacific Maritime forWater Masters Project"
author: "Hannah J McSorley"
date: "2020-01-09"
output: html_document
  theme: Cerulean
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
If needed, install required packages:
```
install.packages("tidyverse")
install.packages("knitr")      
install.packages("gridExtra")  
install.packages("grid")      
```
Note that the tidyverse includes a suite of useful packages, such as:

*readr: for read_csv()
*dplyr: for MANY functions, including mutate() and piping,
*tidyr: for unnest()
*purrr: for map(), reduce()

```{r packages, include = FALSE}
# load packages

suppressPackageStartupMessages(library(tidyverse))  # includes: dplyr, ggplot2, purrr, readr, forcats, lubridate
suppressPackageStartupMessages(library(knitr))      # tidy tables
suppressPackageStartupMessages(library(gridExtra))  # rapid runoff hydrograph/precip plots
suppressPackageStartupMessages(library(grid))       # for rapid runoff plots

```


Create vectors to easily call installation site names from, rather than typing words (efficient and consistent for updating and calling).

```{r tidy-names}

# create a vector of site captions
# NOTE: The site "Weeks Outlet" is being called "Weeks Main Creek"
# match the order of installation from headwaters to mouth/diversion
site_captions <- c("Weeks Main Creek", 
                   "Chris Creek", 
                   "Leech River Head", 
                   "Cragg Creek", 
                   "West Leech River", 
                   "Leech River Tunnel")

# vector for site names (used in data sets variable "site")
(site_names <- c("Weeks-out", "Leech-head", "Chris-crk", "Cragg-crk", "West-Leech", "Tunnel"))

# time-zone note: all loggers record in standard time (no daylight savings shift)
# tz+/- number where the number is hours the timezone is *behind* UTC...
# So UTC-8 means a timezone abbreviated "UTC" that is ???8 hours behind the real UTC, or UTC + 8 hours

TZ <- "Etc/GMT+8"

# use forWater defined colours (hexadecimal codes) for plots
# all colours defined by forWater admin, except 'MyOrange' which I made
forWater_colours <- c(MainBlue = "#09A4D2", 
                      MainGreen = "#668536", 
                      AccentBlue = "#5B99CC", 
                      DarkGrey = "#3B3838", 
                      MyOrange = "#f4AB0E")
```

Bring in data for trip tracking and installation locations:

```{r tracking}
# read in file used to track trips
trip_df <- read.csv(file = "R-inputs_UBC-forWater-MSc_HMc/Leech-FieldTrip-tracking_forWater-MSc_HMc.csv", 
                    header = TRUE)
str(trip_df)

# adjust format of dates
trip_df <- trip_df %>%
  mutate(trip = as_factor(trip),
         trip.start = lubridate::ymd(trip.start, tz = TZ),
         trip.end = lubridate::ymd(trip.end, tz = TZ),
         analysis_date_shimadzu = lubridate::ymd(analysis_date_shimadzu, tz = TZ),
         analysis_date_scan = lubridate::ymd(analysis_date_scan, tz = TZ),
         note = as.character(note))
str(trip_df)

# site installation locations
install_df <- read.csv(file = "R-inputs_UBC-forWater-MSc_HMc/Leech-installation-locations_forWater-MSc_HMc.csv",
                       header = TRUE)
str(install_df)

install_df <- install_df %>%
  mutate(Site_Number = as_factor(Site_Number))

str(install_df)
```

## Water sample data and analytic results

Water samples were collected and transported via coolers (on ice) to UBC's EcoHydrology Lab for analysis of dissolved organic carbon (DOC) concentrations. Samples were filtered through 0.45-micron PES filters; acidified, to bring pH below 2; and analyzed with a Shimadzu TOC-V to quantify DOC (as non-purgeable organic carbon, NPOC) via High-Temperature Combustion Method (5310-B) [@EatonA.D.ClesceriL.S.GreenbergA.E.Franson2000a].

In addition, samples were analyzed using a Spectrolyser spectrophotometer (s::can, Vienna, Austria) which measures turbidity and the chromophoric portion of dissolved organic matter to estimate concentrations of total organic carbon (TOC), DOC as well as nitrate-nitrogen (NO^-3^-N). Samples were also measured for phosphate concentration using a field portable colouremetric test kit (HACH). Each sample had phosphate concentrations below detectable limits (XXXXXX mg/L).   


```{r TOC-V samples}
## Shimadzu TOC-V samples and results
# sample IDs and results from analysis of DOC (as NPOC)


# ------------ SAMPLES ------------ #

# create a data frame of all sample ID data
# for all samples analyzed on Shimadzu TOC-V (UBC ESB 3062)

# input samples directory path
sampledata_path_TOCV <-  "R-inputs_UBC-forWater-MSc_HMc/shimadzu/samples_TOC/"
# read in all the files
shimadzu_samples <- list.files(path = sampledata_path_TOCV, pattern = "*.csv") %>% 
  map(~ read_csv(file.path(sampledata_path_TOCV, .), skip = 4, col_names = TRUE)) %>% 
  reduce(rbind)
# check structure
str(shimadzu_samples)

# correct the sructure/format
shimadzu_samples <- shimadzu_samples %>% 
  dplyr::transmute(vial = as.numeric(vial),
                   site = forcats::as_factor(site),
                   sample_type = forcats::as_factor(`sample-type`),
                   sample = forcats::as_factor(sample),
                   dt_sampled = head(lubridate::ymd_hms(`date-time_sampled`, frac = TRUE, tz = TZ, truncated = 3), -1),
                   fillStage_cm = as.numeric(`fill-stage`),
                   analysis = as_factor(analysis),
                   trip = as_factor(trip))
str(shimadzu_samples)
head(shimadzu_samples)

#check that there are 22 trips
levels(shimadzu_samples$trip)

# check which sites are included
levels(shimadzu_samples$site)

# fix naming errors for sites
shimadzu_samples$site <- shimadzu_samples$site %>% 
  plyr::revalue(c(
    "Chris" = "Chris-crk",
    "Lower-Leech-blw-confl" = "Leech-downstreamconf",
    "Leech-main-confl" = "Leech-downstreamconf",
    "J-Trib" = "West-Jordan",
    "West-jordan" = "West-Jordan",
    "W.Jarvis" = "Jarvis",
    "Rithet-N" = "Rithet",
    "Judge" = "Judge-crk"
  ))
# check sites again
levels(shimadzu_samples$site)

length(levels(shimadzu_samples$site))
#---- samples were collected from a total of 30 sites, 6 were permanent installations ---- #



# ------------ RESULTS ------------ # YOU ARE HERE __ THIS CODE DOES NOT WORK YET & Files for 17 and 18 are short

# input results directory path
resultsdata_path_TOCV <-  "R-inputs_UBC-forWater-MSc_HMc/shimadzu/results_TOC/"
# read in all the files
shimadzu_results <- list.files(path = resultsdata_path_TOCV, pattern = "*.txt") %>% 
  map(~ read_delim(file = file.path(resultsdata_path_TOCV, .), delim = " ", skip = 14, quote = NULL, escape_double = FALSE, escape_backslash = FALSE,
                   col_names = c("Type",	"Anal.",	"Sample Name",	"Sample ID",	"Origin",	"Cal. Curve",	"Manual Dilution Notes",	"Date", "hms", "Am/PM",	"Spl. No.",	"Inj. No.",	"Analysis(Inj.)",	"Area",	"Mean Area",	"Conc.",	"Result",	"Excluded",	"Inj. Vol."))) %>% 
  reduce(rbind)
# check structure
str(shimadzu_results)
head(shimadzu_results)

# test
read_delim(file = "R-inputs_UBC-forWater-MSc_HMc/shimadzu/results_TOC/trip10_TOCV_2019-06-13_Leech-June12.txt", delim = " ",
           skip = 13, 
           col_names = c("Type",	"Analysis",	"Sample Name",	"Sample ID",	"method",	"Cal Curve",	"Manual Dilution Notes",	"Date", "hms", "Am/PM",	"Spl. No.",	"Inj. No.",	"Analysis(Inj.)",	"Area",	"Mean Area",	"Conc.",	"Result",	"Excluded",	"Inj. Vol."))


# correct the sructure/format
shimadzu_results <- shimadzu_results %>% 
  dplyr::transmute(vial = as.numeric(vial),
                   site = forcats::as_factor(site),
                   sample_type = forcats::as_factor(`sample-type`),
                   sample = forcats::as_factor(sample),
                   dt_sampled = head(lubridate::ymd_hms(`date-time_sampled`, frac = TRUE, tz = TZ, truncated = 3), -1),
                   fillStage_cm = as.numeric(`fill-stage`),
                   analysis = as_factor(analysis),
                   trip = as_factor(trip))
str(shimadzu_results)
head(shimadzu_results)


# list all TOC-V results files
shimadzu_results_files <- list.files(path = "/R-inputs_UBC-forWater-MSc_HMc/shimadzu/results/",
                                    recursive = TRUE,
                                    full.names = TRUE)








# ---- OLD ---- #
## vertical rack sample results
# read in the (pre-sorted and organized) vertical rack sample results file
racks_df <- read.csv(file = "2019-04-17_Vertical-Rack_Results.csv", header = TRUE)
str(racks_df)

# format dates
racks_df$analysis_date <- as.POSIXct(racks_df$analysis_date, format="%Y-%m-%d", tz = TZ)

# check structure again
str(racks_df)


# --- #
## grab sample results
# read in the (pre-sorted and organized) grab sample results file
grabs_df <- read.csv(file = "2019-04-17_Grab-Sample_Results.csv", header = TRUE)
str(grabs_df)

# format dates
grabs_df$analysis_date <- as.POSIXct(grabs_df$analysis_date, format="%Y-%m-%d", tz = TZ)
grabs_df$collection.date <- as.POSIXct(grabs_df$collection.date, format="%Y-%m-%d", tz = TZ)

# assign DateTime for grab samples
grabs_df <- grabs_df %>% 
  mutate(Grab_DateTime = as.POSIXct(paste(collection.date, Grab.Time), format="%Y-%m-%d %H:%M", tz = TZ))

# check structure again
str(grabs_df)
head(grabs_df)
tail(grabs_df)

```

Import weather data to generate rapid-runoff plots.

```{r FWx.data}

# read in csv file provided by CRD technologist
# combine separate files and update DateTime format to Posixct
# add a variable of rain in centimeters (stage is in cm)
wx_df <- rbind(
  read.csv(file = "R-inputs/CRD_FWx-Data/2019-04-16_Wx_CC-MG_Sept-Dec2018.csv", header = TRUE),
  read.csv(file = "R-inputs/CRD_FWx-Data/2019-04-16_FWxChris-Creek-trunc.csv", header = TRUE),
  read.csv(file = "R-inputs/CRD_FWx-Data/2019-04-16_FWxMartins-trunc.csv", header = TRUE)) %>% 
  mutate(DateTime = lubridate::ymd_hm(DateTime, tz = TZ), 
         Rn_cm = Rn_mm/10)

str(wx_df)


# Plot Precip from CRD fire weather (FWx) stations

# FWx Chris Creek  
plot_wx_CC <- wx_df %>% 
  filter(StationName == "FWx Chris Creek") %>% 
  ggplot(aes(x = DateTime, y = Rn_cm)) +
  geom_bar(stat = 'identity', fill = forWater_colours[1]) +
  theme_light() +
  labs(y = "Rain (cm)", subtitle = "Chris Creek Wx-Stn") +
  scale_y_reverse()
plot_wx_CC

# FWx Martins Gulch
plot_wx_MG <- wx_df %>% 
  filter(StationName == "FWx Martins Gulch") %>% 
  ggplot(aes(x = DateTime, y = Rn_cm)) +
  geom_bar(stat = 'identity', fill = forWater_colours[1]) +
  theme_light() +
  labs(y = "Rain (cm)", subtitle = "Martins Gulch Wx-Stn") +
  scale_y_reverse()
plot_wx_MG

# set these up for rapid runoff plots later
gpt_wx_CC <- ggplot_gtable(ggplot_build(plot_wx_CC))
gpt_wx_MG <- ggplot_gtable(ggplot_build(plot_wx_MG))


## old code...
# ----------------
## I don't think I need this now -- use 'group_by' or 'filter()' 
# subset into two dataframes for headwaters and reach sites (Chris Creek Wx-stn and Martin's Gulch Wx-stn)
# subset the weather data to match stage data
# Chris Crk Wx-stn (headwaters)
#wx_CC <- subset(wx_df_full, (StationName == "FWx Chris Creek") 
#                & (DateTime >= "2018-10-26 10:00") 
#                & (DateTime <= "2019-04-11 13:00"))  
# Martin's Gulch Wx-stn (Lower reach)
#wx_MG <- subset(wx_df_full, (StationName == "FWx Martins Gulch") 
#                & (DateTime >= "2018-10-26 10:00") 
#                & (DateTime <= "2019-04-11 13:00"))  

# convert rain in mm to cm for comparison to stage rise
#wx_CC$precip.cm <- wx_CC$Rn_mm/10
#wx_MG$precip.cm <- wx_MG$Rn_mm/10

#head(wx_CC)
#head(wx_MG)


# Leech River Tunnel site was installed late
# subset the weather data to match the Tunnel stage data span
#wx_CC_tunnelspan <- subset(wx_df_full, (StationName == "FWx Chris Creek") 
#                           & (DateTime >= "2018-12-07 01:00") 
#                           & (DateTime <= "2019-04-11 13:00"))  
# Martin's Gulch Wx-stn (Lower reach)
#wx_MG_tunnelspan <- subset(wx_df_full, (StationName == "FWx Martins Gulch") 
#                           & (DateTime >= "2018-12-07 01:00") 
#                           & (DateTime <= "2019-04-11 13:00"))  


# ------------ REMOVE?
# special plotting case for Tunnel (late install, different subset with shorter time span)

# FWx_Chris_Creek
#plot_wx_CC_tunnelspan <- ggplot(wx_CC_tunnelspan, aes(DateTime, precip.cm)) +
#  geom_bar(stat = 'identity', fill = forWater_colours[3]) +
#  theme_minimal() +
#  theme(panel.grid = element_blank(), 
#        panel.background = element_blank(),
#        axis.ticks = element_blank(),
#        axis.title.x   = element_blank(),
#        axis.ticks.x    = element_blank()) +
#  ylab("Rain (cm)") +
#  labs(subtitle = "Chris Creek Wx-Stn") +
#  scale_y_reverse()
#plot_wx_CC_tunnelspan

# FWx_Martins_Gulch
#plot_wx_MG_tunnelspan <- ggplot(wx_MG_tunnelspan, aes(DateTime, precip.cm)) +
#  geom_bar(stat = 'identity', fill = forWater_colours[3]) +
#  theme_minimal() +
#  theme(panel.grid = element_blank(), 
#        panel.background = element_blank(),
#        axis.ticks = element_blank(),
#        axis.title.x   = element_blank(),
#        axis.ticks.x    = element_blank()) +
#  ylab("Rain (cm)") +
#  labs(subtitle = "Martin's Gulch Wx-Stn") +
#  scale_y_reverse()
#plot_wx_MG_tunnelspan

# set these up for rainfall-level plots (rapid runoff plot)
#gpt_wx_CC_tunnelspan <- ggplot_gtable(ggplot_build(plot_wx_CC_tunnelspan))
#gpt_wx_MG_tunnelspan <- ggplot_gtable(ggplot_build(plot_wx_MG_tunnelspan))

```

Bring in stage data from Odyssey capacitance water level loggers. Each site has multiple data blocks. Watch for alternating formats of dates.

```{r stage}

## stream level data (second try - bring them in, add a column with site ID combnine them into one then adjust date-times)
# Odyssey Capacitance Water level Loggers installed at 6 sites 
# sites: Weeks Outlet, Leech Rv. Head, Chris Creek, Cragg Creek, West Leech, Leech Tunnel (late install, one data block)
# 3 data blocks exist for each site, date formats are irregular in most

# correct all water level values with offset calculated based on observed and recorded stage 
offset_L.Head   <- 60.84
offset_WksOut   <- 29 # 9.5
offset_ChrisCrk <- 30 # 7.27
offset_CraggCrk <- 9.25
offset_W.Leech  <- 4.85
offset_Tunnel   <- 3.17


# Weeks Outlet (Drainage from Jordan Meadows) -------------------------------
# import all data blocks (3)
stage_Wksout1 <- read.csv(file = "WEEKS-OUTLET_1.csv", header = TRUE, sep = ",", skip = 3)
stage_Wksout2 <- read.csv(file = "WEEKS-OUTLET_2.csv", header = TRUE, sep = ",", skip = 3)
stage_Wksout3 <- read.csv(file = "WEEKS-OUTLET_3.csv", header = TRUE, sep = ",", skip = 3)

# check structures 
str(stage_Wksout1)
str(stage_Wksout2)
str(stage_Wksout3)

# merge into one dateframe 
# add column of site name
# add column of corrected stage (based on calculated offset from observed + logged stage)
stage_Wksout <- rbind(stage_Wksout1, stage_Wksout2, stage_Wksout3) %>% 
  rename("Scans" = X,"Date" = X.1, "Time" = X.2, "Raw.Capacitive.Water.Level" = X.3, "Calibrated.Water.Level_cm" = X.4) %>% 
  mutate(site = site_names[1]) %>% 
  mutate(Stage_cm = Calibrated.Water.Level_cm + offset_WksOut)

str(stage_Wksout)
head(stage_Wksout)
tail(stage_Wksout)

# Leech River Head ----------------------------------------------------------
# import all data blocks (3)
stage_LHead1 <- read.csv(file = "LEECH-HEAD_1.csv", header = TRUE, sep = ",", skip = 3)
stage_LHead2 <- read.csv(file = "LEECH-HEAD_2.csv", header = TRUE, sep = ",", skip = 3)
stage_LHead3 <- read.csv(file = "LEECH-HEAD_3.csv", header = TRUE, sep = ",", skip = 3)

# check structures
str(stage_LHead1)
str(stage_LHead2)
str(stage_LHead3)

# merge into one dateframe 
# add column of site name
# add column of corrected stage 
stage_LHead <- rbind(stage_LHead1, stage_LHead2, stage_LHead3) %>% 
  rename("Scans" = X,"Date" = X.1, "Time" = X.2, "Raw.Capacitive.Water.Level" = X.3, "Calibrated.Water.Level_cm" = X.4) %>% 
  mutate(site = site_names[2]) %>% 
  mutate(Stage_cm = Calibrated.Water.Level_cm + offset_L.Head)

str(stage_LHead)
head(stage_LHead)
tail(stage_LHead)


# Chris Creek ---------------------------------------------------------------
# import all data blocks (3)
stage_Chris1 <- read.csv(file = "CHRIS-CREEK_1.csv", header = TRUE, sep = ",", skip = 3)
stage_Chris2 <- read.csv(file = "CHRIS-CREEK_2.csv", header = TRUE, sep = ",", skip = 3)
stage_Chris3 <- read.csv(file = "CHRIS-CREEK_3.csv", header = TRUE, sep = ",", skip = 3)

# check structures (attention to Date formats)
str(stage_Chris1)
str(stage_Chris2)
str(stage_Chris3)

# merge into one dateframe 
# add column of site name
# add column of corrected stage 
stage_Chris <- rbind(stage_Chris1, stage_Chris2, stage_Chris3) %>% 
  rename("Scans" = X,"Date" = X.1, "Time" = X.2, "Raw.Capacitive.Water.Level" = X.3, "Calibrated.Water.Level_cm" = X.4) %>%
  mutate(site = site_names[3]) %>% 
  mutate(Stage_cm = Calibrated.Water.Level_cm + offset_ChrisCrk)

str(stage_Chris)
head(stage_Chris)
tail(stage_Chris)


# Cragg Creek ------------------------------- 
# import all data blocks (3)
stage_Cragg1 <- read.csv(file = "CRAGG-CREEK_1.csv", header = TRUE, sep = ",", skip = 3)
stage_Cragg2 <- read.csv(file = "CRAGG-CREEK_2.csv", header = TRUE, sep = ",", skip = 3)
stage_Cragg3 <- read.csv(file = "CRAGG-CREEK_3.csv", header = TRUE, sep = ",", skip = 3)

# check structures (attention to Date formats)
str(stage_Cragg1)
str(stage_Cragg2)
str(stage_Cragg3)

# merge into one dateframe 
# add column of site name
# add column of corrected stage 
stage_Cragg <- rbind(stage_Cragg1, stage_Cragg2, stage_Cragg3)%>% 
  rename("Scans" = X,"Date" = X.1, "Time" = X.2, "Raw.Capacitive.Water.Level" = X.3, "Calibrated.Water.Level_cm" = X.4) %>%
  mutate(site = site_names[4]) %>% 
  mutate(Stage_cm = Calibrated.Water.Level_cm + offset_CraggCrk)

str(stage_Cragg)
head(stage_Cragg)
tail(stage_Cragg)

# West Leech River -------------------------------
# import all data blocks (3)
stage_WestL1 <- read.csv(file = "WEST-LEECH_1.csv", header = TRUE, sep = ",", skip = 3)
stage_WestL2 <- read.csv(file = "WEST-LEECH_2.csv", header = TRUE, sep = ",", skip = 3)
stage_WestL3 <- read.csv(file = "WEST-LEECH_3.csv", header = TRUE, sep = ",", skip = 3)

# check structures (attention to Date formats)
str(stage_WestL1)
str(stage_WestL2)
str(stage_WestL3)

# merge into one dateframe 
# add column of site name
# add column of corrected stage 
stage_WestL <- rbind(stage_WestL1, stage_WestL2, stage_WestL3) %>% 
  rename("Scans" = X,"Date" = X.1, "Time" = X.2, "Raw.Capacitive.Water.Level" = X.3, "Calibrated.Water.Level_cm" = X.4) %>%
  mutate(site = site_names[5]) %>% 
  mutate(Stage_cm = Calibrated.Water.Level_cm + offset_W.Leech)

str(stage_WestL)
head(stage_WestL)
tail(stage_WestL)


# Leech River near the Tunnel -------------------------------
# import stage data
stage_Tunnel <- read.csv(file = "LEECH-TUNNEL_1.csv", header = TRUE, sep = ",", skip = 3)

# only one dateframe 
# add column of site name
# add column of corrected stage 
stage_Tunnel <- stage_Tunnel %>% 
  rename("Scans" = X,"Date" = X.1, "Time" = X.2, "Raw.Capacitive.Water.Level" = X.3, "Calibrated.Water.Level_cm" = X.4) %>%
  mutate(site = site_names[6]) %>% 
  mutate(Stage_cm = Calibrated.Water.Level_cm + offset_Tunnel)

str(stage_Tunnel)
head(stage_Tunnel)
tail(stage_Tunnel)


# --- join dataframes --- #
# chack all structures match 
# bind all stage dataframes
# adjust Date formats
# note heterogeneous date formatting: "%d-%m-%Y" AND "%Y-%d-%m"
# use Lubridate::parse_date_time
# create a DateTime column
str(stage_Wksout)
str(stage_LHead)
str(stage_Chris)
str(stage_Cragg)
str(stage_WestL)
str(stage_Tunnel)

stage_df <- rbind(stage_Wksout, stage_LHead, stage_Chris, stage_Cragg, stage_WestL, stage_Tunnel) %>% 
  mutate(Date = parse_date_time(Date, c("dmy", "ydm"), tz = TZ)) %>% 
  mutate(Date = as.POSIXct(Date, tz = TZ)) %>% 
  mutate(DateTime = as.POSIXct(paste(Date, Time), format="%Y-%m-%d %H:%M:%S", tz = TZ))

# check structure and format
str(stage_df)
head(stage_df)
tail(stage_df)


# add a column to stage_df with event ID (based on trip_df)
# trip bounds
strt <- trip_df$trip.start
endt <- trip_df$trip.end
evnt <- trip_df$event_capture

# use logic to identify date intervals and events
# use lubridate:: %within% and 'interval'
stage.event_df <- stage_df %>%
  select(Date, site, Stage_cm, DateTime) %>%
  mutate(
    event = case_when(
    Date %within% interval(strt[1], strt[2]) ~ evnt[1],
    Date %within% interval(strt[2], strt[3]) ~ evnt[2],
    Date %within% interval(strt[3], strt[4]) ~ evnt[3],
    Date %within% interval(strt[4], strt[5]) ~ evnt[4],
    Date %within% interval(strt[5], strt[6]) ~ evnt[5],
    Date %within% interval(strt[6], strt[7]) ~ evnt[6]
  ))

# check out the head tail and middle
head(stage.event_df)
tail(stage.event_df, - 0.2*length(stage.event_df$Date))
tail(stage.event_df, - 0.5*length(stage.event_df$Date))
tail(stage.event_df, - 0.7*length(stage.event_df$Date))
tail(stage.event_df)


# subset to match length of FWx data for rapid runoff plots (sites 1-5)
stage.event_dfSS5 <- subset(stage.event_df, (DateTime >= "2018-10-26 10:00") & (DateTime <= "2019-04-11 13:00"))
# subset to match length of FWx data for rapid runoff plots (site 6)
stage.event_dfSS6 <- subset(stage.event_df, (DateTime >= "2018-12-07 01:00") & (DateTime <= "2019-04-11 13:00"))
```


Make hydrographs with stage (desire is to obtain Q)

```{r hydrographs_1}
setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/")

# run a loop to plot stage for each site
# save each stage plot in a list to call later
stagePlots_list <- vector("list", 6)

# vector to call text format for plots
plottextformat <- element_text(size = 14, colour = forWater_colours[4])

# save a theme vector to add to each plot
stageplottheme <- theme_bw() + 
  theme(legend.title = plottextformat,
        legend.text = plottextformat,
        axis.title = plottextformat,
        axis.text = plottextformat,
        #axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]))

# chose the colour you want
forWater_col <- forWater_colours[3]

# loop for sites 1-5
for (i in seq_along(site_names[1:5])) {
  s <- ggplot(filter(stage.event_dfSS5, site == site_names[i]), aes(x = DateTime, y = Stage_cm)) + 
    geom_point(col = forWater_col) + 
    stageplottheme +
    labs(x = "", y = "Stage (cm)", caption = site_captions[i])
  
  stagePlots_list[[i]] <- s  # save plot to list for calls later (in order of 'site_names')
  ggsave(filename = paste("Stage_Plot_",i,"_",site_names[i],".png"), s)
}

# plot the tunnel separately becasue it has a truncated stage df
s <- ggplot(filter(stage.event_dfSS5, site == site_names[6]), aes(x = DateTime, y = Stage_cm)) + 
    geom_point(col = forWater_col) + 
    stageplottheme +
    labs(x = "", y = "Stage (cm)", caption = site_captions[6])
stagePlots_list[[6]] <- s  # save plot to list for calls later (in order of 'site_names')
ggsave(filename = paste("Stage_Plot_",6,"_",site_names[6],".png"), s)

# rename the stage plot list elements
names(stagePlots_list) <- paste(site_names,"stage")

```

it didn't work to save my graphs in a vector so here they are again, less janky but not totally elegant

```{r hydrographs_2}
setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/")

# set up fresh hydrographs (currently in Janky Shit)
# note: "ggplot_gtable" sets up the plot to be used in grid layout for rapidrunoff plots

# vector to call text format for plots
plottextformat <- element_text(size = 14, colour = forWater_colours[4])

# save a theme vector to add to each plot
stageplottheme <- theme_bw() + 
  theme(legend.title = plottextformat,
        legend.text = plottextformat,
        axis.title = plottextformat,
        axis.text = plottextformat,
        #axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]))

# chose the colour you want
forWater_col <- forWater_colours[3]

# ::: Weeks Outlet 
plot_wks_stg <- 
  ggplot(filter(stage.event_dfSS5, site == site_names[1]), aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  stageplottheme +
  labs(x = "", y = "Stage (cm)", caption = site_captions[i])
ggsave(filename = paste("Stage_Plot_",1,"_",site_names[1],".png"))

gtb_wks_stg <- ggplot_gtable(ggplot_build(plot_wks_stg))  


# :: Leech River Head 
plot_L.head_stg <- 
  ggplot(filter(stage.event_dfSS5, site == site_names[2]), aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  stageplottheme +
  labs(x = "", y = "Stage (cm)", caption = site_captions[i])
ggsave(filename = paste("Stage_Plot_",2,"_",site_names[2],".png"))

gtb_L.head_stg <- ggplot_gtable(ggplot_build(plot_L.head_stg))


# :: Chris Creek 
plot_chris_stg <- 
  ggplot(filter(stage.event_dfSS5, site == site_names[3]), aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  stageplottheme +
  labs(x = "", y = "Stage (cm)", caption = site_captions[i])
ggsave(filename = paste("Stage_Plot_",3,"_",site_names[3],".png"))

gtb_chris_stg <- ggplot_gtable(ggplot_build(plot_chris_stg))


# :: Cragg Creek 
plot_cragg_stg <- 
  ggplot(filter(stage.event_dfSS5, site == site_names[4]), aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  stageplottheme +
  labs(x = "", y = "Stage (cm)", caption = site_captions[i])
ggsave(filename = paste("Stage_Plot_",4,"_",site_names[4],".png"))

gtb_cragg_stg <- ggplot_gtable(ggplot_build(plot_cragg_stg))


# :: West Leech River 
plot_west_stg <- 
  ggplot(filter(stage.event_dfSS5, site == site_names[5]), aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  stageplottheme +
  labs(x = "", y = "Stage (cm)", caption = site_captions[i])
ggsave(filename = paste("Stage_Plot_",5,"_",site_names[5],".png"))

gtb_west_stg <- ggplot_gtable(ggplot_build(plot_west_stg))


# :: Tunnel
plot_tunnel_stg <-
  ggplot(filter(stage.event_dfSS6, site == site_names[6]), aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  stageplottheme +
  labs(x = "", y = "Stage (cm)", caption = site_captions[i])
ggsave(filename = paste("Stage_Plot_",6,"_",site_names[6],".png"))

gtb_tunnel_stg <- ggplot_gtable(ggplot_build(plot_tunnel_stg))
```


#Goal:match bottle height to logged stage

1. read in data files with NPOC concentrations, dates bottles were set and collected, and fill stage (or grab sample dates)
2. read in stage data from Odyssey Capacitance water level loggers
3. fix dates, add identifying/grouping columns for SITE & EVENT
4. filter by site & event & analysis (DOC)
5. match samples to logged stage and extract matching date-time 
6. add DateTime stamps to sample results dataframes

Note: in the future it might be tidier to keep grab samples and rack samples results in one file & one dataframe. They can be easily grouped. For now, we'll keep them separate (gotta make a poster).

Plot the DOC results on each hydrograph

Weeks Outlet (Drainage from Jordan Meadows)

I think you can do thins in a loop with i as the seq_along(site_names[i]) and j as the seq_along(event[j]) 
call vector of events for trip_df

```{r OC+stage_wks}
# --- wks 1
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[1] & event == "1") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[1] & event == "1") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

wks_ev1_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- wks 2
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[1] & event == "2") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[1] & event == "2") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

wks_ev2_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- wks 3
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[1] & event == "3") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[1] & event == "3") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

wks_ev3_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- wks 4
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[1] & event == "4") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[1] & event == "4") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

wks_ev4_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #



# --- wks 5
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[1] & event == "5") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[1] & event == "5") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

wks_ev5_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #
## Event five - freezing event. L1 was recorded as being set at 91 cm but the stage was not recorded as getting that high...


# --- wks 6
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[1] & event == "6") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[1] & event == "6") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)
# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

wks_ev6_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #

## -- This could be improved - possibly with a case_when() or a loop or apply?? --- #


# combine all events into one weeks-df
# no fifth -- wks_matched <- rbind(wks_ev1_df,wks_ev2_df, wks_ev3_df, wks_ev4_df, wks_ev5_df, wks_ev6_df)
wks_matched <- rbind(wks_ev1_df,wks_ev2_df, wks_ev3_df, wks_ev4_df, wks_ev5_df, wks_ev6_df)



# --- make a plot --- #
# find the start of each visit
# use these to add vertical lines to stage plots (for your guidance)
visits <- stage.event_df %>%
  group_by(event) %>% 
  summarise(date = first(DateTime)) %>% 
  ungroup()
visits <- visits[,2]
visits <- visits[[1]]
last_visit <- (last(stage.event_df$DateTime)) 


# vector for visit line colours 
visit_col <- forWater_colours[5]
# rack sample points
point_col <- forWater_colours[5]
# grab colour
grab_col <- forWater_colours[4]


# --- INPUTS --- #
Site.Name <- site_names[1]
rackDOC <- wks_matched
stg_DOCplot <- plot_wks_stg

# grab data (site name)
grabDOC <- grabs_df %>% 
  filter(analysis == "DOC" & Site == site_names[1]) %>% 
  select(Site, sample, filling.stage.cm, Grab_DateTime, Result)
# --- --- --- --- #

# --- get fancy --- #

site.visit.plot <- 
  stg_DOCplot +
  #geom_vline(xintercept = visits[1:6], linetype = "solid", colour = visit_col, size = 0.7) + 
  #geom_vline(xintercept = last_visit, linetype = "solid", colour = visit_col, size = 0.7) +
  geom_point(data = grabDOC, aes(x = Grab_DateTime, y = filling.stage.cm, size = 4), colour = grab_col, show.legend = FALSE) +
  geom_point(data = rackDOC, aes(x = sample_time, y = sample_stage, size = 4), colour = point_col, show.legend = FALSE) 
 site.visit.plot 


# save as a picture
ggsave(paste("sample-hydrgr_", Site.Name, ".png"), plot = site.visit.plot, 
       path = "C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/",
       width = 7.29, height = 4.5, units = "in")

# --- fancy --- #

# set up for combo plot (rainfall-streamflow)
gpt_wks_samp <- ggplot_gtable(ggplot_build(site.visit.plot))

```

# Leech River Head

```{r OC-stage_leech-head}

# --- Leech-Head 1
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[2] & event == "1") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[2] & event == "1") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

L.Head_ev1_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- LHead 2
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[2] & event == "2") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[2] & event == "2") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

L.Head_ev2_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- L.Head 3
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[2] & event == "3") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[2] & event == "3") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

L.Head_ev3_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- L.Head 4
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[2] & event == "4") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[2] & event == "4") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

L.Head_ev4_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- L.Head 5
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[2] & event == "5") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[2] & event == "5") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

L.Head_ev5_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- L.Head 6
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[2] & event == "6") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[2] & event == "6") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

L.Head_ev6_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# combine all events into one weeks-df
L.Head_matched <- rbind(L.Head_ev1_df,L.Head_ev2_df, L.Head_ev3_df, L.Head_ev4_df, L.Head_ev5_df, L.Head_ev6_df)


# --- make a plot --- #
# find the start of each visit
# use these to add vertical lines to stage plots (for your guidance)
visits <- stage.event_df %>%
  group_by(event) %>% 
  summarise(date = first(DateTime)) %>% 
  ungroup()
visits <- visits[,2]
visits <- visits[[1]]
last_visit <- (last(stage.event_df$DateTime)) 


# vector for visit line colours 
visit_col <- forWater_colours[5]
# rack sample points
point_col <- forWater_colours[5]
# grab colour
grab_col <- forWater_colours[4]


# --- INPUTS --- #
Site.Name <- site_names[2]
rackDOC <- L.Head_matched
stg_DOCplot <- plot_L.head_stg

# grab data (site name)
grabDOC <- grabs_df %>% 
  filter(analysis == "DOC" & Site == site_names[2]) %>% 
  select(Site, sample, filling.stage.cm, Grab_DateTime, Result)
# --- --- --- --- #

# --- get fancy --- #

site.visit.plot <- 
  stg_DOCplot +
  #geom_vline(xintercept = visits[1:6], linetype = "solid", colour = visit_col, size = 0.7) + 
  #geom_vline(xintercept = last_visit, linetype = "solid", colour = visit_col, size = 0.7) +
  geom_point(data = grabDOC, aes(x = Grab_DateTime, y = filling.stage.cm, size = 4), colour = grab_col, show.legend = FALSE) +
  geom_point(data = rackDOC, aes(x = sample_time, y = sample_stage, size = 4), colour = point_col, show.legend = FALSE) 
 site.visit.plot 
  
# save as a picture
ggsave(paste("sample-hydrgr_", Site.Name, ".png"), plot = site.visit.plot, 
       path = "C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/",
       width = 7.29, height = 4.5, units = "in")

# --- fancy --- #

# set up for combo plot (rainfall-streamflow)
gpt_LHead_samp <- ggplot_gtable(ggplot_build(site.visit.plot))
```

# Chris Creek

```{r OC-stage_chris-creek}

# --- Chriscrk 1
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[3] & event == "1") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[3] & event == "1") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

Chriscrk_ev1_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- Chriscrk 2
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[3] & event == "2") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[3] & event == "2") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

Chriscrk_ev2_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- Chriscrk 3
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[3] & event == "3") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[3] & event == "3") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)
# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

Chriscrk_ev3_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- Chriscrk 4
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[3] & event == "4") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[3] & event == "4") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

Chriscrk_ev4_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- Chriscrk 5
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[3] & event == "5") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[3] & event == "5") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

Chriscrk_ev5_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- Chriscrk 6
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[3] & event == "6") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[3] & event == "6") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

Chriscrk_ev6_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #

# combine all events into one weeks-df
Chriscrk_matched <- rbind(Chriscrk_ev1_df, Chriscrk_ev2_df, Chriscrk_ev3_df, Chriscrk_ev4_df, Chriscrk_ev5_df, Chriscrk_ev6_df)

# --- make a plot --- #
# find the start of each visit
# use these to add vertical lines to stage plots (for your guidance)
visits <- stage.event_df %>%
  group_by(event) %>% 
  summarise(date = first(DateTime)) %>% 
  ungroup()
visits <- visits[,2]
visits <- visits[[1]]
last_visit <- (last(stage.event_df$DateTime)) 

# vector for visit line colours 
visit_col <- forWater_colours[5]
# rack sample points
point_col <- forWater_colours[5]
# grab colour
grab_col <- forWater_colours[4]


# --- INPUTS --- #
Site.Name <- site_names[3]
rackDOC <- Chriscrk_matched
stg_DOCplot <- plot_chris_stg

# grab data (site name)
grabDOC <- grabs_df %>% 
  filter(analysis == "DOC" & Site == site_names[3]) %>% 
  select(Site, sample, filling.stage.cm, Grab_DateTime, Result)
# --- --- --- --- #

# --- get fancy --- #

site.visit.plot <- 
  stg_DOCplot +
  #geom_vline(xintercept = visits[1:6], linetype = "solid", colour = visit_col, size = 0.7) + 
  #geom_vline(xintercept = last_visit, linetype = "solid", colour = visit_col, size = 0.7) +
  geom_point(data = grabDOC, aes(x = Grab_DateTime, y = filling.stage.cm, size = 4), colour = grab_col, show.legend = FALSE) +
  geom_point(data = rackDOC, aes(x = sample_time, y = sample_stage, size = 4), colour = point_col, show.legend = FALSE) 
 site.visit.plot 
  
# save as a picture
ggsave(paste("sample-hydrgr_", Site.Name, ".png"), plot = site.visit.plot, 
       path = "C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/",
       width = 7.29, height = 4.5, units = "in")

# --- fancy --- #

# set up for combo plot (rainfall-streamflow)
gpt_Crscrk_samp <- ggplot_gtable(ggplot_build(site.visit.plot))
```

# Cragg Creek

```{r OC-stage_cragg}

# --- cragg 1
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[4] & event == "1") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[4] & event == "1") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

cragg_ev1_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- cragg 2
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[4] & event == "2") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[4] & event == "2") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

cragg_ev2_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- cragg 3
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[4] & event == "3") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[4] & event == "3") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)
# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

cragg_ev3_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- cragg 4
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[4] & event == "4") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[4] & event == "4") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

cragg_ev4_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- cragg 5
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[4] & event == "5") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[4] & event == "5") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

cragg_ev5_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- cragg 6
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[4] & event == "6") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[4] & event == "6") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

cragg_ev6_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #

# combine all events into one weeks-df
# no fifth -- wks_matched <- rbind(wks_ev1_df,wks_ev2_df, wks_ev3_df, wks_ev4_df, wks_ev5_df, wks_ev6_df)
cragg_matched <- rbind(cragg_ev1_df, cragg_ev2_df, cragg_ev3_df, cragg_ev4_df, cragg_ev5_df, cragg_ev6_df)

# --- make a plot --- #
# find the start of each visit
# use these to add vertical lines to stage plots (for your guidance)
visits <- stage.event_df %>%
  group_by(event) %>% 
  summarise(date = first(DateTime)) %>% 
  ungroup()
visits <- visits[,2]
visits <- visits[[1]]
last_visit <- (last(stage.event_df$DateTime)) 

# vector for visit line colours 
visit_col <- forWater_colours[5]
# rack sample points
point_col <- forWater_colours[5]
# grab colour
grab_col <- forWater_colours[4]


# --- INPUTS --- #
Site.Name <- site_names[4]
rackDOC <- cragg_matched
stg_DOCplot <- plot_cragg_stg

# grab data (site name)
grabDOC <- grabs_df %>% 
  filter(analysis == "DOC" & Site == site_names[4]) %>% 
  select(Site, sample, filling.stage.cm, Grab_DateTime, Result)
# --- --- --- --- #

# --- get fancy --- #
site.visit.plot <- 
  stg_DOCplot +
  #geom_vline(xintercept = visits[1:6], linetype = "solid", colour = visit_col, size = 0.7) + 
  #geom_vline(xintercept = last_visit, linetype = "solid", colour = visit_col, size = 0.7) +
  geom_point(data = grabDOC, aes(x = Grab_DateTime, y = filling.stage.cm, size = 4), colour = grab_col, show.legend = FALSE) +
  geom_point(data = rackDOC, aes(x = sample_time, y = sample_stage, size = 4), colour = point_col, show.legend = FALSE) 
 site.visit.plot 
 
# save as a picture
ggsave(paste("sample-hydrgr_", Site.Name, ".png"), plot = site.visit.plot, 
       path = "C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/",
       width = 7.29, height = 4.5, units = "in")

# --- fancy --- #

# set up for combo plot (rainfall-streamflow)
gpt_Craggcrk_samp <- ggplot_gtable(ggplot_build(site.visit.plot))
```

# West Leech River

```{r OC-stage_west}

# --- west 1
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[5] & event == "1") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[5] & event == "1") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

west_ev1_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- west 2
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[5] & event == "2") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[5] & event == "2") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

west_ev2_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- west 3
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[5] & event == "3") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[5] & event == "3") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)
# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

west_ev3_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- west 4
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[5] & event == "4") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[5] & event == "4") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

west_ev4_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- west 5
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[5] & event == "5") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[5] & event == "5") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

west_ev5_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- west 6
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[5] & event == "6") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[5] & event == "6") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

west_ev6_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #

# combine all events into one weeks-df
west_matched <- rbind(west_ev1_df, west_ev2_df, west_ev3_df, west_ev4_df, west_ev5_df, west_ev6_df)

# --- make a plot --- #
# find the start of each visit
# use these to add vertical lines to stage plots (for your guidance)
visits <- stage.event_df %>%
  group_by(event) %>% 
  summarise(date = first(DateTime)) %>% 
  ungroup()
visits <- visits[,2]
visits <- visits[[1]]
last_visit <- (last(stage.event_df$DateTime)) 

# vector for visit line colours 
visit_col <- forWater_colours[5]
# rack sample points
point_col <- forWater_colours[5]
# grab colour
grab_col <- forWater_colours[4]


# --- INPUTS --- #
Site.Name <- site_names[5]
rackDOC <- west_matched
stg_DOCplot <- plot_west_stg

# grab data (site name)
grabDOC <- grabs_df %>% 
  filter(analysis == "DOC" & Site == site_names[5]) %>% 
  select(Site, sample, filling.stage.cm, Grab_DateTime, Result)
# --- --- --- --- #

# --- get fancy --- #
site.visit.plot <- 
  stg_DOCplot +
  #geom_vline(xintercept = visits[1:6], linetype = "solid", colour = visit_col, size = 0.7) + 
  #geom_vline(xintercept = last_visit, linetype = "solid", colour = visit_col, size = 0.7) +
  geom_point(data = grabDOC, aes(x = Grab_DateTime, y = filling.stage.cm, size = 4), colour = grab_col, show.legend = FALSE) +
  geom_point(data = rackDOC, aes(x = sample_time, y = sample_stage, size = 4), colour = point_col, show.legend = FALSE) 
 site.visit.plot 
 
# save as a picture
ggsave(paste("sample-hydrgr_", Site.Name, ".png"), plot = site.visit.plot, 
       path = "C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/",
       width = 7.29, height = 4.5, units = "in")

# --- fancy --- #

# set up for combo plot (rainfall-streamflow)
gpt_WestL_samp <- ggplot_gtable(ggplot_build(site.visit.plot))

```

# Leech River Tunnel

```{r OC-stage_tunnel}
# this site was installed late, in December
# event 1 for the tunnel was "event 3" for all others...


# --- tunnel 1 (3)
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[6] & event == "3") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[6] & event == "3") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

tunnel_ev1_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- tunnel 2 (4)
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[6] & event == "4") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[6] & event == "4") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

tunnel_ev2_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- tunnel 3 (5)
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[6] & event == "5") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[6] & event == "5") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)
# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

tunnel_ev3_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #


# --- tunnel 4 (6)
# --- INPUTS --- #
# create subset working dataframes 
stg_df <- filter(stage.event_df, site == site_names[6] & event == "6") %>% 
  select(event, site, DateTime, Stage_cm)

samp_df <- filter(racks_df, analysis == "DOC" & site == site_names[6] & event == "6") %>% 
  select(event, site, sample, Fill.Stage_cm, analysis, Result)

# --- OUTPUTS --- #
# defined based on your INPUT values (no need to alter)

# this is the stage date you're targeting (by site)
stg <- stg_df$Stage_cm
# this is the time series you're targeting
t.series <- stg_df$DateTime  
# this is the stage you need a date-time for
level <- samp_df$Fill.Stage_cm 

# assign empty vectors to hold the outputs from the loop
l <- length(samp_df$sample)
occur_fill <- vector(length = l)
stg_fill   <- vector(length = l)
time_fill  <- vector(length = l)

for (i in seq_along(samp_df$sample)) {
  occur_fill[i] <- detect_index(stg, ~ .x >= level[i], .right = FALSE)
  stg_fill[i] <- stg[occur_fill[i]]
} 

tunnel_ev4_df <- samp_df %>% 
  select(event, site, Fill.Stage_cm, analysis, Result) %>% 
  mutate(index = occur_fill, sample_stage = stg_fill, sample_time = t.series[occur_fill])
# --- #



# combine all events into one weeks-df
#west_ev3_df, west_ev4_df, 
tunnel_matched <- rbind(tunnel_ev1_df, tunnel_ev2_df, tunnel_ev3_df, tunnel_ev4_df)

# --- make a plot --- #
# find the start of each visit
# use these to add vertical lines to stage plots (for your guidance)
visits <- stage.event_df %>%
  group_by(event) %>% 
  summarise(date = first(DateTime)) %>% 
  ungroup()
visits <- visits[,2]
visits <- visits[[1]]
last_visit <- (last(stage.event_df$DateTime)) 

# vector for visit line colours 
visit_col <- forWater_colours[5]
# rack sample points
point_col <- forWater_colours[5]
# grab colour
grab_col <- forWater_colours[4]


# --- INPUTS --- #
Site.Name <- site_names[6]
rackDOC <- tunnel_matched
stg_DOCplot <- plot_tunnel_stg

# grab data (site name)
grabDOC <- grabs_df %>% 
  filter(analysis == "DOC" & Site == site_names[6]) %>% 
  select(Site, sample, filling.stage.cm, Grab_DateTime, Result)
# --- --- --- --- #

# --- get fancy --- #
site.visit.plot <- 
  stg_DOCplot +
  #geom_vline(xintercept = visits[1:6], linetype = "solid", colour = visit_col, size = 0.7) + 
  #geom_vline(xintercept = last_visit, linetype = "solid", colour = visit_col, size = 0.7) +
  geom_point(data = grabDOC, aes(x = Grab_DateTime, y = filling.stage.cm, size = 4), colour = grab_col, show.legend = FALSE) +
  geom_point(data = rackDOC, aes(x = sample_time, y = sample_stage, size = 4), colour = point_col, show.legend = FALSE) 
 site.visit.plot 

# save as a picture
ggsave(paste("sample-hydrgr_", Site.Name, ".png"), plot = site.visit.plot, 
       path = "C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/",
       width = 7.29, height = 4.5, units = "in")


# --- fancy --- #

# set up for combo plot (rainfall-streamflow)
gpt_Tunnel_samp <- ggplot_gtable(ggplot_build(site.visit.plot))
```

# make rapid runoff plots with the sample hydrographs

```{r rainfall-runoff_sample_plots}
setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/")

# create rainfall and stream level plots and save each as an image

# Site 1 ------------------------------- 
# Weeks Lake Outlet 
# with CC-Wx 
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gpt_wks_samp$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gpt_wks_samp$widths[2:3] <- maxWidth

rr_WksOut_CC <- grid.arrange(gpt_wx_CC, gpt_wks_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_WksOut-CC.png", rr_WksOut_CC)


# Site 2  ------------------------------- 
# Leech River Head (below colfluence of Chris and Weeks) 
# with CC-Wx
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gpt_LHead_samp$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gpt_LHead_samp$widths[2:3] <- maxWidth

rr_LHead_CC <- grid.arrange(gpt_wx_CC, gpt_LHead_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_LHead-CC.png", rr_LHead_CC)


# Site 3  ------------------------------- 
# Chris Creek
# with CC-Wx 
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], gpt_Crscrk_samp$widths[2:3])
gpt_wx_CC$widths[2:3]  <- maxWidth
gpt_Crscrk_samp$widths[2:3] <- maxWidth

rr_chris_CC <- grid.arrange(gpt_wx_CC, gpt_Crscrk_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_chris-CC.png", rr_chris_CC)


# Site 4   ------------------------------- 
# Cragg Creek 
# with CC-Wx 
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gpt_Craggcrk_samp$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gpt_Craggcrk_samp$widths[2:3] <- maxWidth

rr_cragg_CC <- grid.arrange(gpt_wx_CC, gpt_Craggcrk_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_cragg-CC.png", rr_cragg_CC)


# Cragg Creek
# with MG-Wx 
maxWidth <- unit.pmax(gpt_wx_MG$widths[2:3], 
                      gpt_Craggcrk_samp$widths[2:3])
gpt_wx_MG$widths[2:3] <- maxWidth
gpt_Craggcrk_samp$widths[2:3] <- maxWidth

rr_cragg_MG <- grid.arrange(gpt_wx_MG, gpt_Craggcrk_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_cragg-MG.png", rr_cragg_MG)


# Site 5  ------------------------------- 
# West Leech River 
# with MG-Wx
maxWidth <- unit.pmax(gpt_wx_MG$widths[2:3], 
                      gpt_WestL_samp$widths[2:3])
gpt_wx_MG$widths[2:3] <- maxWidth
gpt_WestL_samp$widths[2:3] <- maxWidth

rr_WLeech_MG <- grid.arrange(gpt_wx_MG, gpt_WestL_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_WLeech-MG.png", rr_WLeech_MG)


# West Leech River
# with CC-Wx
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gpt_WestL_samp$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gpt_WestL_samp$widths[2:3] <- maxWidth

rr_WLeech_CC <- grid.arrange(gpt_wx_CC, gpt_WestL_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_WLeech-CC.png", rr_WLeech_CC)


# Site 6  ------------------------------- This one isn't lined up properly b/c late installation 
# Leech River Tunnel 
# with CC-Wx
maxWidth <- unit.pmax(gpt_wx_CC_tunnelspan$widths[2:3], 
                      gpt_Tunnel_samp$widths[2:3])
gpt_wx_CC_tunnelspan$widths[2:3] <- maxWidth
gpt_Tunnel_samp$widths[2:3] <- maxWidth

rr_Tunnel_CC <- grid.arrange(gpt_wx_CC_tunnelspan, gpt_Tunnel_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_Tunnel-CC.png", rr_Tunnel_CC)

# Leech River Tunnel 
# with MG-wx
maxWidth <- unit.pmax(gpt_wx_CC_tunnelspan$widths[2:3], 
                      gpt_Tunnel_samp$widths[2:3])
gpt_wx_MG_tunnelspan$widths[2:3] <- maxWidth
gpt_Tunnel_samp$widths[2:3] <- maxWidth

rr_Tunnel_MG <- grid.arrange(gpt_wx_MG_tunnelspan, gpt_Tunnel_samp, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-sampplot_Tunnel-MG.png", rr_Tunnel_MG)

```

# This is tidy and logical code :)
result is 'DOCresults_df'
```{r summary stats}
setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/")
# first, combine all the matched rack results (sample, levels, DOC, sample_DateTime) from each site
racksDOC <- rbind(wks_matched, L.Head_matched, Chriscrk_matched, cragg_matched, west_matched, tunnel_matched) %>%
  mutate(sample_type = "rack") %>% 
  rename(sample_DateTime = sample_time, 
         obs.filling.stage = Fill.Stage_cm,
         racksample_stage = sample_stage) %>% 
  select(-index) 

str(racksDOC)

# next, filter grabs results for DOC and combine with rack results
# grabs data (all sites) 
str(grabs_df)

grabsDOC <- grabs_df %>% 
  filter(analysis == "DOC") %>% 
  select(event = event_capture, 
         site = Site, 
         obs.filling.stage = filling.stage.cm, 
         analysis, 
         Result,
         sample_DateTime = Grab_DateTime 
         ) %>% 
  mutate(sample_type = "Grab",
         racksample_stage = "NA"
  )
# check the structures match
str(grabsDOC)
str(racksDOC)

# merge the two 
DOCresults_df <- rbind(grabsDOC, racksDOC)
str(DOCresults_df)

# add latitude and longitude so you can import this to QGIS
# check names
install_df$Sample_Name
unique(DOCresults_df$site)
site_names

# match lat and long to site names
DOCresults_df <- DOCresults_df %>% 
  mutate(
    latitude = case_when(
      DOCresults_df$site == site_names[1] ~ install_df$Latitude[1],
      DOCresults_df$site == site_names[2] ~ install_df$Latitude[2],
      DOCresults_df$site == site_names[3] ~ install_df$Latitude[3],
      DOCresults_df$site == site_names[4] ~ install_df$Latitude[4],
      DOCresults_df$site == site_names[5] ~ install_df$Latitude[5],
      DOCresults_df$site == site_names[6] ~ install_df$Latitude[6]),
    longitude = case_when(
      DOCresults_df$site == site_names[1] ~ install_df$Longitude[1],
      DOCresults_df$site == site_names[2] ~ install_df$Longitude[2],
      DOCresults_df$site == site_names[3] ~ install_df$Longitude[3],
      DOCresults_df$site == site_names[4] ~ install_df$Longitude[4],
      DOCresults_df$site == site_names[5] ~ install_df$Longitude[5],
      DOCresults_df$site == site_names[6] ~ install_df$Longitude[6])
    )

# check structure
str(DOCresults_df)

# add a column for sampling month
DOCresults_df <- DOCresults_df %>% mutate(sample_month = month(sample_DateTime, label = TRUE))
str(DOCresults_df)

# save a copy as a csv file
write.csv(DOCresults_df, file = "2019-05-26_combined-DOC-results.csv")


# --- --- --- --- #  
  
# summary stats
str(DOCresults_df)

DOC_stats <- DOCresults_df %>% 
  filter(analysis == "DOC") %>% 
  group_by(sample_month, site) %>% 
  summarize(count = n(), DOCmean = mean(Result), DOCsd = sd(Result), DOCmedian = median(Result), DOCmin = min(Result), DOCmax = max(Result))
head(DOC_stats)
tail(DOC_stats)
str(DOC_stats)

write.csv(DOC_stats, file = "2019-05-26_DOC-SummaryStats.csv")


# summary stats 2.0
str(DOCresults_df)

DOC_stats2 <- DOCresults_df %>% 
  filter(analysis == "DOC") %>% 
  group_by(site) %>% 
  summarize(count = n(), DOCmean = mean(Result), DOCsd = sd(Result), DOCmin = min(Result), DOCmedian = median(Result), DOCmax = max(Result))
head(DOC_stats2)
tail(DOC_stats2)
str(DOC_stats2)

write.csv(DOC_stats2, file = "2019-05-28_DOC-SummaryStats.csv")

# summary stats 3.0
str(DOCresults_df)

DOC_stats3 <- DOCresults_df %>% 
  filter(analysis == "DOC") %>% 
  group_by(site, sample_type) %>% 
  summarize(count = n(), DOCmean = mean(Result), DOCsd = sd(Result), DOCmin = min(Result), DOCmedian = median(Result), DOCmax = max(Result))
head(DOC_stats3)
tail(DOC_stats3)
str(DOC_stats3)

write.csv(DOC_stats3, file = "2019-05-28_DOC-SummaryStats3.csv")

```

```{r DOC_plots}
setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/")
# check dataframe
str(DOCresults_df)

# get factors in order for tidy calls
# set sample type to be factor
DOCresults_df$sample_type <- as.factor(DOCresults_df$sample_type)
str(DOCresults_df)

# add ordered site factor (headwater to reach)
DOCresults_df$site_f <- factor(DOCresults_df$site, levels=c("Weeks-out", "Chris-crk", "Leech-head", "Cragg-crk", "West-Leech", "Tunnel"))
levels(DOCresults_df$site_f) <- site_captions2  # rename with caption names

# add ordered months (fall 2018 to spring 2019)
DOCresults_df$month_f <- factor(DOCresults_df$sample_month, levels=c("Oct", "Nov", "Dec", "Jan", "Feb", "Mar", "Apr"))

# vector to call text format for plots
textformat <- element_text(size = 14, colour = forWater_colours[4])

# make plots
# boxplot and scatter plot of DOC at all sites over first wet season
DOC_facetB.Plot <- DOCresults_df %>% filter(analysis == "DOC") %>% group_by(sample_type) %>% 
  ggplot(aes(x = month_f, y = Result, fill = sample_type, colour = sample_type)) + geom_boxplot() +
  scale_fill_manual(values = c("white", "white")) + guides(fill = FALSE) +
  geom_point(aes(colour = sample_type), size = 3) +
  scale_color_manual(values = c(forWater_colours[1], forWater_colours[5]),
                     labels = c("Grab", "Rack")) +
  theme_bw() +
  theme(legend.position = "top",
        legend.title = textformat,
        legend.text = textformat,
        axis.title = textformat,
        strip.text = element_text(size = 12, colour = forWater_colours[4]),
        axis.text = textformat) +
  labs(colour = "Sample Type:  ") +
  ylab("Dissolved Organic Carbon (mg/L NPOC)") + 
  xlab("") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~site_f) 
DOC_facetB.Plot

# scatterplot of DOC at all sites over first wet season
# scatter only (better than box plot version I think)
DOC_facet_SPlot <- DOCresults_df %>% filter(analysis == "DOC") %>% group_by(sample_type) %>% 
  ggplot(aes(x = sample_DateTime, y = Result)) +
  geom_point(aes(colour = sample_type), size = 5, alpha = 0.75) +  # partially transparent points with alpha <1
  scale_color_manual(values=c(forWater_colours[4], forWater_colours[5]),
                     labels = c("Grab", "Rack")) +
  theme_bw() +
  theme(legend.position = "top",
        legend.title = textformat,
        legend.text = textformat,
        axis.title = textformat,
        strip.text = element_text(size = 12, colour = forWater_colours[4]),
        axis.text = textformat) +
  labs(colour = "Sample Type:  ") +
  ylab("DOC (mg/L NPOC)") + 
  xlab("") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~site_f) 
DOC_facet_SPlot

ggsave(filename = "DOC_facet-scatterPlot_allSites.png", DOC_facet_SPlot)


# scatterplot of DOC at each site
# set it up and run a loop
# use vectors defined in chunk "tidy-names"

for (i in seq_along(site_names)) {
  g <- DOCresults_df %>% filter(analysis == "DOC" & site == site_names[i]) %>% group_by(sample_type) %>% 
  ggplot(aes(x = sample_DateTime, y = Result)) + 
  geom_point(aes(colour = sample_type), size = 5) +
  theme_bw() +
  theme(plot.caption = textformat,
        legend.position = c(0.8, 0.8),
        legend.text = textformat,
        legend.title = textformat,
        axis.text = textformat,
        axis.title = textformat) +
  labs(colour = "Sample Type") +
       #caption = paste("DOC over 2018-2019 wet season at ", site_captions[i])) +
  scale_color_manual(values=c(forWater_colours[4], forWater_colours[5]),
                     labels = c("Grab", "Rack")) +
  ylab("NPOC (mg/L DOC)") + 
  xlab("")

ggsave(filename = paste("DOC_scatterPlot_",i,"_",site_names[i],".png"),
       width = 7.29, height = 4.5, units = "in")
}

# YAY that worked!!!! 
# Go back to your janky mess of plots above (when you have time) and fix that code up to be cool like this!!! :)

```

See if there is a direct relationship (suspected) between DOC (from grabs) and metals resutls

import both files and combine.

```{r DOC-metals}

setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/")

# read in grab sample data
grabs_df <- read.csv("2019-05-24_Grab-Sample_TOC-V_Results.csv")
str(grabs_df)

grabs_df$analysis_date <- as.POSIXct(grabs_df$analysis_date, tz = TZ)
grabs_df <- grabs_df %>% 
  mutate(collection_DateTime = as.POSIXct(paste(collection.date, collection.time), format="%Y-%m-%d %H:%M", tz = TZ))
str(grabs_df)

# read in metals + DOC data (manually merged)
metals_df <- read.csv("Leech_metals+DOC_compiled.csv", stringsAsFactors = FALSE)
str(metals_df)

# sample collection date-time as POSIXct
metals_df$Sampling.Date <- parse_date_time(metals_df$Sampling.Date, c("Ymd HM"), tz = TZ)
rename(metals_df, Sample_DateTime = Sampling.Date)
metals_df$Site <- as.factor(metals_df$Site.1)
metals_df <- subset(metals_df, select = c(-Site.1))
str(metals_df)


# replace analytical results that are below reportable detection limits with NA
# there should be a way tidier to loop over the whole data frame rather than cherry picking the character columns 
# this works, but only if the SCV format never changes
for(i in c(9, 11, 12, 14:20, 22:26, 28, 30:36, 39, 41)) {
  is.na(metals_df[,i]) <- startsWith(metals_df[,i], "<")
  }

# convert from wide to long format
# The arguments to gather():
# - data: original (wide) Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
metals_long <- gather(metals_df, key = "parameter", value = "result", 
                      NPOC_mg.L:Total.Sulphur..S._mg.L, na.rm=TRUE, convert=TRUE, factor_key=FALSE)
str(metals_long)

# results should be numeric not character
# convert all results values to numeric
metals_long$result <- sapply(metals_long$result, as.numeric)
str(metals_long)
head(metals_long)
tail(metals_long)

write.csv(metals_long, file = "R-outputs/2019-05-26_metals-long.csv")
write.csv(metals_df, file = "R-outputs/2019-05-26_metals-wide.csv")


```

```{r plot_metals}

setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/")

metals_nona <- read.csv("2019-05-26_metals-wide_filtered.csv")

# add ordered factor for headwater to reach
metals_nona$Site_f <- factor(metals_nona$Site, levels=c("Weeks-out", "Chris-crk", "Leech-head", "Cragg-crk", "West-Leech", "Tunnel"))
levels(metals_nona$Site_f) <- site_captions

metalsnames <- as.vector(colnames(metals_nona))
metalsnames

metalsnames[8]
CaCo3 <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,8])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Total Hardness (mg/L CaCO3)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
CaCo3

metalsnames[9]
Hg <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,9])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Mercury (ug/L Hg)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Hg

metalsnames[10]
Al <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,10])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Aluminum (ug/L Al)") + 
  xlab("DOC (mg/L)") +
  geom_hline(yintercept = 100, linetype = "solid", colour = forWater_colours[5], size = 0.4) +
  facet_wrap(~Site_f) 
Al

metalsnames[12]
Ba <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,12])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Barium (ug/L Ba)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Ba

metalsnames[15]
Cu <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,15])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Copper (ug/L Cu)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Cu

metalsnames[16]
Fe <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,16])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Iron (ug/L Fe)") + 
  xlab("DOC (mg/L)") +
  geom_hline(yintercept = 300, linetype = "solid", colour = forWater_colours[5], size = 0.4) +
  facet_wrap(~Site_f) 
Fe

metalsnames[17]
Mn <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,17])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Manganese (ug/L Mn)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Mn

metalsnames[19]
Si <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,19])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Silicon (ug/L Si)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Si

metalsnames[21]
Sr <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,21])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Strontium (ug/L Sr)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Sr

metalsnames[24]
Ca <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,24])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Calcium (ug/L Ca)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Ca

metalsnames[25]
Mg <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,25])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Magnesium (ug/L Mg)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Mg

metalsnames[26]
K <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,26])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("potassium (ug/L K)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
K

metalsnames[27]
Na <- metals_nona %>% 
  ggplot(aes(x = NPOC_mg.L, y = metals_nona[,27])) + 
  geom_point(aes(colour = Trip), size = 4) +
  ylab("Sodium (ug/L Na)") + 
  xlab("DOC (mg/L)") +
  facet_wrap(~Site_f) 
Na

# save pics
ggsave("metals_CaCo3.png", CaCo3)
ggsave("metals_Hg.png", Hg)
ggsave("metals_Al.png", Al)
ggsave("metals_Ba.png", Ba)
ggsave("metals_Cu.png", Cu)
ggsave("metals_Fe.png", Fe)
ggsave("metals_Mn.png", Mn)
ggsave("metals_Si.png", Si)
ggsave("metals_Sr.png", Sr)
ggsave("metals_Ca.png", Ca)
ggsave("metals_Mg.png", Mg)
ggsave("metals_K.png", K)
ggsave("metals_Na.png", Na)

```

# 2019-05-27 
Retrying hydrograph plots with sample dots
this didn't work - keep trying
The problem was that I couldn't call the hydrograph plot I saved to a list to add it to a new ggplot() with geom_points
But I think I should be able to...


```{r chemograph_inprogress}



# plot_wks_stg, plot_L.head_stg, plot_chris_stg, plot_cragg_stg, plot_west_stg, plot_tunnel_stg

# try this

# assign rack + grab subset
rack_ss <- filter(DOCresults_df, analysis == "DOC" & sample_type == "rack")
grab_ss <- filter(DOCresults_df, analysis == "DOC" & sample_type == "Grab")

c <- plot_wks_stg +
  geom_point(data = rack_ss, aes(x = sample_DateTime, y = racksample_stage), colour = forWater_colours[4], size = 5) +
  geom_point(data = grab_ss, aes(x = sample_DateTime, y = obs.filling.stage), colour = forWater_colours[4], size = 5)
c 

## still not working

# old 
# --- INPUTS --- #
Site.Name <- site_names[1]
rackDOC <- wks_matched
stg_DOCplot <- plot_wks_stg
# grab data (site name)
grabDOC <- grabs_df %>% 
  filter(analysis == "DOC" & Site == site_names[1]) %>% 
  select(Site, sample, filling.stage.cm, Grab_DateTime, Result)
# --- get fancy --- #
c <- stg_DOCplot +
  geom_point(data = grabDOC, aes(x = Grab_DateTime, y = filling.stage.cm, size = 4), colour = forWater_colours[4], show.legend = FALSE) +
  geom_point(data = rackDOC, aes(x = sample_time, y = sample_stage, size = 4), colour = forWater_colours[5], show.legend = FALSE) 
c 
# --- --- --- --- # end old, start new

# new

# use results df
str(DOCresults_df)
# call on 'stagePlots_list' and 'site_names' to access hydrographs and names (1:6)


# --- INPUTS --- #
Site.Name <- site_names[1]
DOCdf <- DOCresults_df %>% filter(site == site_names[1] & analysis == "DOC")
hydrograph <- stagePlots_list[1]

b <- DOCresults_df %>% filter(site == site_names[1] & analysis == "DOC") %>% 
  ggplot(aes(x = sample_DateTime, y = racksample_stage)) +
  geom_point(aes(colour = sample_type), size = 4) 
b 

# stage-plot + geom_point(sample_data)

# --- diff code example
# scatterplot of DOC at each site
# set it up and run a loop
# use vectors defined in chunk "tidy-names"

for (i in seq_along(site_names)) {
  g <- DOCresults_df %>% filter(analysis == "DOC" & site == site_names[i]) %>% group_by(sample_type) %>% 
  ggplot(aes(x = sample_DateTime, y = Result)) + 
  geom_point(aes(colour = sample_type), size = 5) +
  theme_bw() +
  theme(plot.caption = textformat,
        legend.position = c(0.8, 0.8),
        legend.text = textformat,
        legend.title = textformat,
        axis.text = textformat,
        axis.title = textformat) +
  labs(colour = "Sample Type",
       caption = paste("DOC over 2018-2019 wet season at ", site_captions[i])) +
  scale_color_manual(values=c(forWater_colours[4], forWater_colours[5]),
                     labels = c("Grab", "Rack")) +
  ylab("NPOC (mg/L DOC)") + 
  xlab("")

ggsave(filename = paste("DOC_scatterPlot_",i,"_",site_names[i],".png"), g)
}

# save as a picture
ggsave(paste("sample-hydrgr_", Site.Name, ".png"), plot = site.visit.plot, 
       path = "C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/R-outputs/",
       width = 7.29, height = 4.5, units = "in")

# --- fancy --- #
```




# fix up this janky code:

```{r JankyShit_fix_gtables}

## ------- you got this far in jank repair ---------##
# set up for combo plot (rainfall-streamflow)
# save each stage plot in a list to call later
stg_gtable_list <- vector("list", 6)

for (i in seq_along(stagePlots_list)) {
  stg_gtable_list[[i]] <- ggplot_gtable(ggplot_build(stagePlots_list[i]))
}

# rename the list elements of stage plot ggplot gtables
names(stg_gtable_list) <- paste(site_names,"gtable")



# ****** YOU CANT GET RID OF THIS BECAUSE THE JANKY CHEMOGRAPHS PULL ON THESE HYDROGRAPHS - UGH *** ######
# don't use this janky shit 
# BUT -- make sure you got the the ggplot gtables set up properly in your loop (to build rapid-runoff plots (but make them better, the rain bars are too thin to see))

#### -- janky shit Below --- ####
# Janky but it works

# chose the colour you want
forWater_col <- forWater_colours[3]

# --- Weeks Lake Outlet --- #
plot_wks_stg <- ggplot(filter(stage.event_dfSS5, site == site_names[1]), 
                       aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]),
        axis.text = element_text(colour = forWater_colours[4])) +
  labs(x = "", y = "Stage (cm)", caption = site_captions[1])
plot_wks_stg 

# set up for combo plot (rainfall-streamflow)
gtb_wks_stg <- ggplot_gtable(ggplot_build(plot_wks_stg))


# --- Leech River Head --- #
plot_L.head_stg <- ggplot(filter(stage.event_dfSS5, site == site_names[2]), 
                          aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  theme_minimal() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]),
        axis.text = element_text(colour = forWater_colours[4])) +
  labs(x = "", y = "Stage (cm)", caption = site_captions[2])
plot_L.head_stg 

# set up for combo plot (rainfall-streamflow)
gtb_L.head_stg <- ggplot_gtable(ggplot_build(plot_L.head_stg))


# --- Chris Creek --- #
plot_chris_stg <- ggplot(filter(stage.event_dfSS5, site == site_names[3]), 
                         aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  theme_minimal() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]),
        axis.text = element_text(colour = forWater_colours[4])) +
  labs(x = "", y = "Stage (cm)", caption = site_captions[3])
plot_chris_stg 

# set up for combo plot (rainfall-streamflow)
gtb_chris_stg <- ggplot_gtable(ggplot_build(plot_chris_stg))

## note data gap 2018-11-07 -- date of re-build. 
# Original installation by Bill Floyd was at an angle, Nov 7 Stew and Hannah re-built the station to be vertical and match other designs. 
# In the original structure, the sensor was laying against the inside of the stilling well (possibly resulting in a positive bias)
# the angled stilling well may have extended the offset (if the stilling well wasn't against the streambed). 
# all bottle heights for the pre and post period are matched to the stilling well, so they should still line up.


# --- Cragg Creek --- #
plot_cragg_stg <- ggplot(filter(stage.event_dfSS5, site == site_names[4]), 
                         aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  theme_minimal() + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]),
        axis.text = element_text(colour = forWater_colours[4])) +
  labs(x = "", y = "Stage (cm)", caption = site_captions[4])
plot_cragg_stg 

# set up for combo plot (rainfall-streamflow)
gtb_cragg_stg <- ggplot_gtable(ggplot_build(plot_cragg_stg))


# --- West Leech River (above the confluence with Leech mainstem) --- #
plot_west_stg <- ggplot(filter(stage.event_dfSS5, site == site_names[5]), 
                        aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  theme_minimal() + 
   theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]),
        axis.text = element_text(colour = forWater_colours[4])) +
  labs(x = "", y = "Stage (cm)", caption = site_captions[5])
plot_west_stg 

# set up for combo plot (rainfall-streamflow)
gtb_west_stg <- ggplot_gtable(ggplot_build(plot_west_stg))



# --- Tunnel --- #
plot_tunnel_stg <- ggplot(filter(stage.event_dfSS6, site == site_names[6]), 
                          aes(x = DateTime, y = Stage_cm)) + 
  geom_point(col = forWater_col) + 
  theme_minimal() + 
   theme(#axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(colour = forWater_colours[4]),
        axis.text = element_text(colour = forWater_colours[4])) +
  labs(x = "", y = "Stage (cm)", caption = site_captions[6])
plot_tunnel_stg 

# set up for combo plot (rainfall-streamflow)
gtb_tunnel_stg <- ggplot_gtable(ggplot_build(plot_tunnel_stg))


```

Create rainfall runoff plots

```{r rainfall-runoff_plots_janky}

setwd("C:/Users/Hannah/Documents/UBC_MSc/Analyses+Laboratory+Tracking_forWater-MSc_HMc/Data_WORKUP_forWater-MSc_HMc/")

# create rainfall and stream level plots and save each as an image

# Site 1 ------------------------------- 
# Weeks Lake Outlet 
# with CC-Wx 
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gtb_wks_stg$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gtb_wks_stg$widths[2:3] <- maxWidth

rr_WksOut_CC <- grid.arrange(gpt_wx_CC, gtb_wks_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_WksOut-CC.png", rr_WksOut_CC)


# Site 2  ------------------------------- 
# Leech River Head (below colfluence of Chris and Weeks) 
# with CC-Wx
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gtb_L.head_stg$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gtb_L.head_stg$widths[2:3] <- maxWidth

rr_LHead_CC <- grid.arrange(gpt_wx_CC, gtb_L.head_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_LHead-CC.png", rr_LHead_CC)


# Site 3  ------------------------------- 
# Chris Creek
# with CC-Wx 
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], gtb_chris_stg$widths[2:3])
gpt_wx_CC$widths[2:3]  <- maxWidth
gtb_chris_stg$widths[2:3] <- maxWidth

rr_chris_CC <- grid.arrange(gpt_wx_CC, gtb_chris_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_chris-CC.png", rr_chris_CC)


# Site 4   ------------------------------- 
# Cragg Creek 
# with CC-Wx 
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gtb_cragg_stg$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gtb_cragg_stg$widths[2:3] <- maxWidth

rr_cragg_CC <- grid.arrange(gpt_wx_CC, gtb_cragg_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_cragg-CC.png", rr_cragg_CC)


# Cragg Creek
# with MG-Wx 
maxWidth <- unit.pmax(gpt_wx_MG$widths[2:3], 
                      gtb_cragg_stg$widths[2:3])
gpt_wx_MG$widths[2:3] <- maxWidth
gtb_cragg_stg$widths[2:3] <- maxWidth

rr_cragg_MG <- grid.arrange(gpt_wx_MG, gtb_cragg_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_cragg-MG.png", rr_cragg_MG)


# Site 5  ------------------------------- 
# West Leech River 
# with MG-Wx
maxWidth <- unit.pmax(gpt_wx_MG$widths[2:3], 
                      gtb_west_stg$widths[2:3])
gpt_wx_MG$widths[2:3] <- maxWidth
gtb_west_stg$widths[2:3] <- maxWidth

rr_WLeech_MG <- grid.arrange(gpt_wx_MG, gtb_west_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_WLeech-MG.png", rr_WLeech_MG)


# West Leech River
# with CC-Wx
maxWidth <- unit.pmax(gpt_wx_CC$widths[2:3], 
                      gtb_west_stg$widths[2:3])
gpt_wx_CC$widths[2:3] <- maxWidth
gtb_west_stg$widths[2:3] <- maxWidth

rr_WLeech_CC <- grid.arrange(gpt_wx_CC, gtb_west_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_WLeech-CC.png", rr_WLeech_CC)


# Site 6  ------------------------------- This one isn't lined up properly b/c late installation 
# Leech River Tunnel 
# with CC-Wx
maxWidth <- unit.pmax(gpt_wx_CC_tunnelspan$widths[2:3], 
                      gtb_tunnel_stg$widths[2:3])
gpt_wx_CC_tunnelspan$widths[2:3] <- maxWidth
gtb_tunnel_stg$widths[2:3] <- maxWidth

rr_Tunnel_CC <- grid.arrange(gpt_wx_CC_tunnelspan, gtb_tunnel_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_Tunnel-CC.png", rr_Tunnel_CC)

# Leech River Tunnel 
# with MG-wx
maxWidth <- unit.pmax(gpt_wx_CC_tunnelspan$widths[2:3], 
                      gtb_tunnel_stg$widths[2:3])
gpt_wx_MG_tunnelspan$widths[2:3] <- maxWidth
gtb_tunnel_stg$widths[2:3] <- maxWidth

rr_Tunnel_MG <- grid.arrange(gpt_wx_MG_tunnelspan, gtb_tunnel_stg, ncol = 1, heights = c(1, 3))
ggsave("R-outputs/rr-plot_Tunnel-MG.png", rr_Tunnel_MG)

```




